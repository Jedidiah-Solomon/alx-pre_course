GIT is a Version Control System (VCS).

Uses of GITHUB
*Creating a repository
*Forking a repository
*Managing files
*Being social



How to add images , table to a readme.md
*# JedybrownFolio
 My website.

<img alt="My pics" src="https://user-images.githubusercontent.com/121108148/215294524-739aad63-9d80-4d8f-8273-c0d633853d5e.jpg" width="200" height="200">
 This link was gotten from github issue by dragging pc image into description box.                                                                                                   


<details>
    <summary> My Top Languages </summary>

    |   RANK          |Specializations
    |----------------:|---------------|
    |     1           |  HTML         |
    |     2           |  CSS          |
    |     3           |  JAVASCRIPT   |
    |     4           |  PHP          |

</details>





GIT COMMANDS
$ git clone <repo>
//




$ touch test
$ git add test
$ git commit -m "Initial commit"
$ git push origin main


some COMMANDS
1. cd
2. ls
3. mkdir
4. rmdir 
Just like Sandbox
5. Create a folder with mkdir e.g "my_class" and use cd to go to the content 
of the directory, then use 
git init
this will create a GIT Repository inside this directory
to get this message
Initialized empty Git repository in C:/Users/JEDYBROWN/Desktop/my_class/.git/

Using the terminal we navigated to the folder location and invoked the
magic words, git init, where init is short for initialize. Git realizes we
are asking it to create a repository at this location, and it responds by
creating a hidden folder called .git, and stuffs it with some configuration
files, and a subfolder where it will store our snapshots when we ask it to.
One way to confirm this happened is by listing all the files using our
terminal, like so.
This hidden folder represents the Git repository. It’s job is to store
everything related to your project, including all commits, the project
history, configuration files, what-have-you. It also stores any specific Git
configuration and settings that might have enabled for this particular
project.
output: JEDYBROWN@DESKTOP-EP9RSDS MINGW64 ~/Desktop/my_class (master)
$ ls -a
./  ../  .git/


so,
git config --global user.name "Jedidiah Solomon"
will write your usernam globally
git config --global user.email "onwubikojedidiah@gmail.com"
will write your mail

create a file Checklist.md inside my_class folder
Save the file as Checklist.md in the my_class directory.
Now we are ready to commit our work. This involves two Git commands,
namely:
git add and git commit.
$ git add checklist.md will add the file to GIT


$ git commit -m "Jedy first commit" 
will commit this file to git and you will see this below:
[master (root-commit) 7150e6a] Jedy first commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 checklist.md

 We saw that committing to Git is a two-step process. You first add the files
and then commit.
The first thing to know is that only the files that you add are committed.
Let’s say you had two files—Checklist.md and README.md, but you only
added Checklist.md.  When you create a commit, Git will only store the
changes made to Checklist.md.
Now, when we commit, Git uses a specialized algorithm to safely tuck
away everything that we added in it’s memory. When we say we
“committed” our changes to Git, what that translates into is that Git creates
a commit object that it stores inside the .git folder. This commit object is
‘stamped’ by a unique identifier. You might recall that we got 3dc1ea2 when
we made our commit in our last exercise (you certainly saw something
different)—this is actually a much longer string containing numbers and
letters that looks something like this.

GIT command has 3 parts:
1. command e.g git
2. sub-command e.g add 
3. argument e.g "checklist"

Note the commands are in small letters.
* git commit takes 2 messages
1. a flag e.g -m
2. message e.g "First commit by me"
When we add a new file to a Git repository, Git sees the file, but also
chooses not to do anything till we explicitly tell it to. A file that Git has
never seen before (that is, a file that has never been added to the index) is
marked as “Untracked”. Adding the file to the index is our way of telling Git
“Hey! We really like you to keep an eye on this file for us”. Any file that Git
is watching for us is referred to as a “tracked” file.




git status 
tells you the status of commit as it stands

Once you install Git, you need to tell Git your full name, and
your email address. Git will use this whenever you use Git to


How to undo a Git commit
First, decide how far back to go into the version history. To view the previous commits, use the git log  command. This provides the commit details.

Once the IT team chooses a code version to which their tree should revert, use the commit ID to execute the command. In the following example, x12345 represents the commit ID, gained from the git log output:

git reset x12345

Alternatively, there is a shorthand method to roll back the commit: To revert commits without knowing the necessary commit ID, admins can use the command below to revert code versions relative to where the current head is. In the example, ~1 refers to the number of commits backward to which the code tree will revert. Figure 1 illustrates the results for adding several commits and then reverting back one version.

git reset head~1



git add README.md                       //for a single file
git add --all                            // for multiple files or use shorthand 
git add -A
git add *.txt                           // to add all .txt files
git commit -m "Write your message"
git commit -a               // this is to amend a code you have added and commited the first time.
git help
git command -help           or          // for help
git help --all
'git help -a' and 'git help -g' list available subcommands and some
concept guides. See 'git help <command>' or 'git help <concept>'
to read about a specific subcommand or concept.
See 'git help git' for an overview of the system.

if using Sublime text, when to write commit message, clean all messages and type your commit message.
Ensure you always add before commiting
                                        





git branch classroom_box                    //will create a branch called classroom_box
                                                                                                                     
git checkout classroom_box              //will switch us from master to the branch 
git checkout -b                 //will create another branch under this new branch


git merge classroom_box  ///For merging this branch and main but pls use checkout to switch to main before doing
this.

 git branch -d classroom_box                //will delete the branch classroom_box      but pls use checkout to switch to main before doing this.
 Create your github account, the copy the url and do
 $ git remote add origin https://github.com/Jedidiah-Solomon/practice_hub.git/              //step 1
 $ git push --set-upstream origin master                                                    /step 2

 or

git remote add origin https://github.com/Jedidiah-Solomon/practice_hub.git  //step1
git branch -M main                                                          //step 2
git push -u origin main                                                     //step 3




git add "filename"                      //stages a file
use 
git rm --cached                         //to unstage
 


git --version           //to check version.


Note: Short status flags are:

?? - Untracked files
A - Files added to stage
M - Modified files
D - Deleted files

Pulling to Keep up-to-date with Changes
When working as a team on a project, it is important that everyone stays up to date.

Any time you start working on a project, you should get the most recent changes to your local copy.

With Git, you can do that with pull.

pull is a combination of 2 different commands:

fetch
merge
Let's take a closer look into how fetch, merge, and pull works.

Git Fetch
fetch gets all the change history of a tracked branch/repo.

So, on your local Git, fetch updates to see what has changed on GitHub
git fetch origin

The result looks like:
remote: Enumerating objects: 4, done.
remote: Counting objects: 100% (4/4), done.
remote: Compressing objects: 100% (3/3), done.
remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
Unpacking objects: 100% (3/3), 749 bytes | 0 bytes/s, done.
From https://github.com/Jedidiah-Solomon/practice_hub
   bd661fc..72797ed  main       -> origin/main


Now that we have the recent changes, we can check our status:

Example
git status

The result is :

We are behind the origin/master by 1 commit. That should be the updated README.md, but lets double check by viewing the log:

Example
git log origin/master

That looks as expected, but we can also verify by showing the differences between our local master and origin/master:

Example
git diff origin/master

That looks precisely as expected! Now we can safely merge.

Git Merge
merge combines the current branch, with a specified branch.

We have confirmed that the updates are as expected, and we can merge our current branch (master) with origin/master:

Example
git merge origin/master


Git Pull
But what if you just want to update your local repository, without going through all those steps?

pull is a combination of fetch and merge. It is used to pull all changes from a remote repository into the branch you are working on.

Make another change to the Readme.md file on GitHub.

Use pull to update our local Git:

Example
git pull origin



Push Changes to GitHub
Let's try making some changes to our local git and pushing them to GitHub.
Commit the changes:

Example
git commit -a -m "Updated index.html. Resized image"
And check the status:

Example
git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)

nothing to commit, working tree clean
Now push our changes to our remote origin:

Example
git push origin



git branch              //tells you the branch you ae working
git branch -a       //So we can use the -a option to see all local and remote branches.



Push a Branch to GitHub
Let's try to create a new local branch, and push that to GitHub.

Start by creating a branch, like we did earlier:

Example
git checkout -b update-readme
ow push the branch from our local Git repository, to GitHub, where everyone can see the changes:

Example
git push origin update-readme



A clone is a full copy of a repository, including all logging and versions of files.
Open your Git bash and clone the repository:

Example
git clone https://github.com/w3schools-test/w3schools-test.github.io.git
Note: To specify a specific folder to clone to, add the name of the folder after the repository URL,
 like this: git clone https://github.com/w3schools-test/w3schools-test.github.io.git myfolder


Git Revert Find Commit in Log
First thing, we need to find the point we want to return to. To do that, we need to go through the log.

To avoid the very long log list, we are going to use the --oneline option, which gives just one line per 
commit showing:

The first seven characters of the commit hash
the commit message
So let's find the point we want to revert:



Example
git log --oneline
52418f7 (HEAD -> master) Just a regular update, definitely no accidents here...
9a9add8 (origin/master) Added .gitignore
81912ba Corrected spelling error
3fdaa5b Merge pull request #1 from w3schools-test/update-readme
836e5bf (origin/update-readme, update-readme) Updated readme for GitHub Branches
daf4f7c (origin/html-skeleton, html-skeleton) Updated index.html with basic meta
facaeae (gh-page/master) Merge branch 'master' of https://github.com/w3schools-test/hello-world
e7de78f Updated index.html. Resized image
5a04b6f Updated README.md with a line about focus
d29d69f Updated README.md with a line about GitHub
e0b6038 merged with hello-world-images after fixing conflicts
1f1584e added new image
dfa79db updated index.html with emergency fix
0312c55 Added image to Hello World
09f4acd Updated index.html with a new line
221ec6e First release of Hello World!

We want to revert to the previous commit: 52418f7 (HEAD -> master) Just a
 regular update, definitely no accidents here..., 
and we see that it is the latest commit.


Git Revert HEAD
We revert the latest commit using git revert HEAD (revert the latest change,  and then commit), adding the option --no-edit to skip the commit message editor (getting the default revert message):

Example
git revert HEAD --no-edit



Git Reset
reset is the command we use when we want to move the repository back to a previous commit, 
discarding any changes made after that commit.

Git Reset
We reset our repository back to the specific commit using git reset commithash (commithash being the first 7 characters of the commit hash we found in the log):

Example
git reset 9a9add8










Git commit --amend
commit --amend is used to modify the most recent commit.

It combines changes in the staging environment with the latest commit, and creates a new commit.

This new commit replaces the latest commit entirely.

Git Amend Commit Message
One of the simplest things you can do with --amend is to change a commit message.

Let's update the README.md and commit:

Example
git commit -m "Adding plines to reddme"
[master 07c5bc5] Adding plines to reddme
 1 file changed, 3 insertions(+), 1 deletion(-)
Now let's check the log:

Example
git log --oneline
Oh no! the commit message is full of spelling errors. Embarrassing. Let's amend that:

Example
git commit --amend -m "Added lines to README.md"